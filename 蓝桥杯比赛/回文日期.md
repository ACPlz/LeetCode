# 题目描述
## 2020 年春节期间，有一个特殊的日期引起了大家的注意：2020 年 2 月 2 日。因为如果将这个日期按 “yyyymmdd” 的格式写成一个 8 位数是 20200202，恰好是一个回文数。我们称这样的日期是回文日期。
## 有人表示 20200202 是 “千年一遇” 的特殊日子。对此小明很不认同，因为不到 2 年之后就是下一个回文日期：20211202 即 2021 年 12 月 2 日。
## 也有人表示 20200202 并不仅仅是一个回文日期，还是一个 ABABBABA 型的回文日期。对此小明也不认同，因为大约 100 年后就能遇到下一个 ABABBABA 型的回文日期：21211212 即 2121 年 12 月 12 日。算不上 “千年一遇”，顶多算 “千年两遇”。
## 给定一个 8 位数的日期，请你计算该日期之后下一个回文日期和下一个 ABABBABA 型的回文日期各是哪一天。
### 我的题解：
```#include <iostream>
using namespace std;
long long n;
int isRight(int nums) {
  int a[8];
  for (int i = 0; i < 8; i++) {
    a[i] = nums % 10;
    nums /= 10;
  }
  int j = 7;
  for (int i = 0; i <= 3; i++) {
    if (a[i] != a[j]) return 0;
    j--;
  }
  if (a[4] > 1 || (a[4] == 1 && a[5] > 2) || a[6] > 3 || (a[4] == 0 && a[5] == 0) || (a[6] == 0 && a[7] == 0)) return 0;
  if (a[0] == a[2] && a[1] == a[3]) return 1;
  return 2;
}
int main()
{
  cin>>n;
  int result1 = 100000000;
  int result2 = n;
  for (int i = n + 1; i <= 99999999; i++) {
    if (isRight(i) == 2 || isRight(i) == 1) {
      result1 = min(result1, i);
    }
    if (isRight(i) == 1) {
      result2 = i;
      break;
    }
  }
  cout<<result1<<endl;
  cout<<result2<<endl;
  return 0;
}
```

### **备注**：双指针法判断是否是回文数，从i +1处开始循环到89991231（说实话看到题目的N处在这个区间内应该要反应过来）
### 特别需要注意的是，需要特别判断一下日期月份不能超过12，日不能超过31（如果更细致的话是不是还应该有几月份大几月份小这种说法哈哈哈，但是没判断就过了）