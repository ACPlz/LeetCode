# 题目描述
## 给你一份工作时间表 hours，上面记录着某一位员工每天的工作小时数。
## 我们认为当员工一天中的工作小时数大于 8 小时的时候，那么这一天就是「劳累的一天」。
## 所谓「表现良好的时间段」，意味在这段时间内，「劳累的天数」是严格 大于「不劳累的天数」。
## 请你返回「表现良好时间段」的最大长度。
### 我的题解：
```class Solution {
public:
    int longestWPI(vector<int>& hours) {
        int s = 0;
        int result = 0;
        unordered_map<int, int> m1;
        for (int i = 0; i < hours.size(); i++) {
            if (hours[i] > 8) s++;
            else s--;
            if (s > 0) result = i + 1;
            else if (m1.count(s - 1)) result = max(result, i - m1[s - 1]);
            if (!m1.count(s)) m1[s] = i;
        }
        return result;
    }
};
```
### **备注**：题目简化：说白了就是求数组内大于8的元素数量占比更大的子数组的最大长度
### 由于只分为劳累以及不劳累，可以把劳累看成1，不劳累看成-1，那么可以用前缀和来判断子数组是否符合表现良好的条件
### 设s为当前坐标的前缀和，若其> 0则表明大于8的元素占比肯定更多，当前坐标+1记录子数组长度
### 若s < 0,比如s = -1，那么就需要去找到比s更小的第一个前缀和的坐标，比如在i = 2处s = -2, i = 8处s = -1，那么他们中间的数组肯定符合表现良好的条件（因为该子数组相加的和为1